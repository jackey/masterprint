<?php

class cryptastic {

    public function encrypt( $msg, $k = 'master print key', $base64 = false ) {
        if ( ! $td = mcrypt_module_open('rijndael-256', '', 'ctr', '') )
            return false;
 
        $msg = serialize($msg);                         # serialize
        $iv = mcrypt_create_iv(32, MCRYPT_RAND);        # create iv
 
        if ( mcrypt_generic_init($td, $k, $iv) !== 0 )  # initialize buffers
            return false;
 
        $msg = mcrypt_generic($td, $msg);               # encrypt
        $msg = $iv . $msg;                              # prepend iv
        $mac = $this->pbkdf2($msg, $k, 1000, 32);       # create mac
        $msg .= $mac;                                   # append mac
 
        mcrypt_generic_deinit($td);                     # clear buffers
        mcrypt_module_close($td);                       # close cipher module
 
        if ( $base64 ) $msg = base64_encode($msg);      # base64 encode?
 
        return $msg;                                    # return iv+ciphertext+mac
    }
    
    public function decrypt( $msg, $k = 'master print key', $base64 = false ) {
        if ( $base64 ) $msg = base64_decode($msg);          # base64 decode?
        if ( ! $td = mcrypt_module_open('rijndael-256', '', 'ctr', '') )
            return false;
        $iv = substr($msg, 0, 32);                          # extract iv
        $mo = strlen($msg) - 32;                            # mac offset
        $em = substr($msg, $mo);                            # extract mac
        $msg = substr($msg, 32, strlen($msg)-64);           # extract ciphertext
        $mac = $this->pbkdf2($iv . $msg, $k, 1000, 32);     # create mac
 
        if ( $em !== $mac )                                 # authenticate mac
            return false;
 
        if ( mcrypt_generic_init($td, $k, $iv) !== 0 )      # initialize buffers
            return false;
 
        $msg = mdecrypt_generic($td, $msg);                 # decrypt
        $msg = unserialize($msg);                           # unserialize
 
        mcrypt_generic_deinit($td);                         # clear buffers
        mcrypt_module_close($td);                           # close cipher module
 
        return $msg;                                        # return original msg
    }
 
    public function pbkdf2( $p, $s, $c, $kl, $a = 'sha256' ) {
 
        $hl = strlen(hash($a, null, true)); # Hash length
        $kb = ceil($kl / $hl);              # Key blocks to compute
        $dk = '';                           # Derived key
        for ( $block = 1; $block <= $kb; $block ++ ) {
            $ib = $b = hash_hmac($a, $s . pack('N', $block), $p, true);
            for ( $i = 1; $i < $c; $i ++ )
                $ib ^= ($b = hash_hmac($a, $b, $p, true));
 
            $dk .= $ib; # Append iterated block
        }
        return substr($dk, 0, $kl);
    }
}

$iv = mcrypt_create_iv (mcrypt_get_block_size (MCRYPT_TripleDES, MCRYPT_MODE_CBC), MCRYPT_DEV_RANDOM);
$salt = 'master print key';

$string = json_encode(array('name' => 'admin', 'pass' => 'admin'));

/**
 * Implements hook_boot()
 */
function masterprint_hash_boot() {

}

function encrypt($text) {
	// global $salt;
 //    return trim(base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $salt, $text, MCRYPT_MODE_ECB, mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND))));
	$c = new cryptastic();
	return $c->encrypt($text);
}

function decrypt($text) {
	// global $salt;
 //    return trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $salt, base64_decode($text), MCRYPT_MODE_ECB, mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND)));
	$c = new cryptastic();
	return $c->decrypt($text);
}
